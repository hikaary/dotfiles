#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AI MR Helper

Скрипт для генерации заголовка и описания Merge Request на основе diff между ветками Git.
Добавлена поддержка использования Gemini Free API (модель gemini-2.5flash) через метод generateContent.
Для предотвращения ошибок по размеру запроса, большой diff обрезается до максимального размера.
"""
import argparse
import json
import os
import subprocess
import urllib.error
import urllib.request



def notify(title: str, message: str) -> None:
    """
    Отправляет системное уведомление через notify-send.

    :param title: Заголовок уведомления
    :param message: Сообщение уведомления
    """
    subprocess.run(['notify-send', title, message])


def set_clipboard_text(text: str) -> None:
    """
    Копирует текст в системный буфер обмена через wl-copy.

    :param text: Текст для копирования
    """
    process = subprocess.Popen(['wl-copy'], stdin=subprocess.PIPE)
    process.communicate(input=text.encode('utf-8'))


def send_openrouter_request(api_key: str, model: str, prompt: str) -> dict | None:
    """
    Посылает запрос к OpenRouter API для выбранной модели.
    """
    url = 'https://openrouter.ai/api/v1/chat/completions'
    data = {
        'model': model,
        'messages': [{'role': 'user', 'content': prompt}],
    }
    data_json = json.dumps(data).encode('utf-8')
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {api_key}',
    }
    req = urllib.request.Request(url, data=data_json, headers=headers, method='POST')
    try:
        with urllib.request.urlopen(req) as resp:
            return json.loads(resp.read().decode('utf-8'))
    except urllib.error.HTTPError as err:
        notify('AI MR Helper', f'HTTP Error: {err.code} {err.reason}\n{err.read().decode()}')
    except urllib.error.URLError as err:
        notify('AI MR Helper', f'URL Error: {err.reason}')
    return None


def send_gemini_free_request(api_key: str, prompt: str) -> dict | None:
    """
    Посылает запрос к Gemini Free API через endpoint generateContent.

    Использует метод v1beta в URL и передаёт API-ключ в параметре ?key=.
    Тело запроса: {"contents":[{"parts":[{"text": prompt}]}]}
    """
    url = f'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key={api_key}'
    payload = {
        'contents': [
            {'parts': [{'text': prompt}]}
        ]
    }
    data_json = json.dumps(payload).encode('utf-8')
    headers = {'Content-Type': 'application/json; charset=utf-8'}
    req = urllib.request.Request(url, data=data_json, headers=headers, method='POST')
    try:
        with urllib.request.urlopen(req) as resp:
            return json.loads(resp.read().decode('utf-8'))
    except urllib.error.HTTPError as err:
        notify('AI MR Helper (Gemini)', f'HTTP Error: {err.code} {err.reason}\n{err.read().decode()}')
    except urllib.error.URLError as err:
        notify('AI MR Helper (Gemini)', f'URL Error: {err.reason}')
    return None


def parse_args() -> argparse.Namespace:
    """
    Парсит аргументы командной строки.

    --use-gemini-free: использовать Gemini Free API вместо OpenRouter
    """
    parser = argparse.ArgumentParser(description='AI MR Helper')
    parser.add_argument('--use-gemini-free', action='store_true', help='Использовать Gemini Free API')
    return parser.parse_args()


def main() -> None:
    """
    Основная функция: собирает diff, обрезает его при необходимости,
    отправляет запрос к выбранному API и копирует ответ.
    """
    args = parse_args()

    # Получение ключа
    if args.use_gemini_free:
        api_key = os.getenv('GEMINI_API_KEY') or os.getenv('GOOGLE_API_KEY')
        if not api_key:
            notify('AI MR Helper', 'GEMINI_API_KEY не установлена.')
            return
    else:
        api_key = os.getenv('OPENROUTER_API_KEY')
        if not api_key:
            notify('AI MR Helper', 'OPENROUTER_API_KEY не установлена.')
            return

    # Получение diff
    target_branch = input('Введите ветку, в которую делается MR: ').strip()
    if not target_branch:
        print('Целевая ветка не указана. Выход.')
        return
    try:
        current_branch = subprocess.check_output(
            ['git', 'rev-parse', '--abbrev-ref', 'HEAD'], encoding='utf-8'
        ).strip()
        diff = subprocess.check_output(
            ['git', 'diff', f'{target_branch}..{current_branch}'], encoding='utf-8'
        )
    except subprocess.CalledProcessError as e:
        notify('AI MR Helper', f'Ошибка Git: {e}')
        return
    if not diff.strip():
        notify('AI MR Helper', 'Нет изменений между ветками для отображения diff.')
        return

    text_diff = diff

    prompt = f"""
# РОЛЬ: Ты опытный AI-ассистент, специализирующийся на анализе кода и подготовке Merge Request (MR). Твоя задача – помочь разработчикам быстро понять суть изменений и ускорить процесс ревью.

# ЗАДАЧА: На основе предоставленного diff изменений между ветками Git, создай информативный заголовок (Title) и структурированное подробное описание (Description) для Merge Request. Ответ должен быть полностью на русском языке.

# ВХОДНЫЕ ДАННЫЕ (Diff для анализа):

{text_diff}

# ИНСТРУКЦИИ ПО СОЗДАНИЮ MR:

## 1. Заголовок (Title):
*   **Краткость и ясность:** Сформулируй лаконично, не более 72 символов.
*   **Информативность:** Четко отрази основное изменение или цель данного MR.
*   **Формат (Рекомендованный):** Используй префиксы, указывающие на *основной* тип изменений (по аналогии с Conventional Commits), чтобы сразу было понятно направление работы:
    *   `feat:` для новой функциональности.
    *   `fix:` для исправления ошибки.
    *   `refactor:` для рефакторинга без изменения поведения.
    *   `perf:` для улучшения производительности.
    *   `docs:` для изменений только в документации.
    *   `test:` для добавления/изменения тестов.
    *   `chore:` для рутинных задач (обновление зависимостей, конфигов и т.п.).
    *   *Пример:* `feat(api): Добавить эндпоинт для получения профиля пользователя`
    *   *Пример:* `fix: Исправить расчет скидки для оптовых заказов`

## 2. Описание (Description):
*   **Цель:** Предоставить достаточный контекст, объяснить суть изменений и помочь ревьюерам эффективно проверить код.
*   **Структура:** Используй Markdown и четкие разделы. Предлагаемая структура (адаптируй содержание на основе анализа diff):

    **Что сделано:**
    *   Краткое резюме внесенных изменений.
    *   Выдели *все* основные типы изменений, обнаруженные в diff: `feat`, `fix`, `refactor`, `perf`, `docs`, `test`, `chore`, `style`. Используй списки для наглядности.

    **Зачем это сделано:**
    *   Объясни мотивацию или бизнес-требование, стоящее за изменениями.

    **Как проверить (опционально, если применимо):**
    *   Краткие шаги для тестирования или проверки внесенных изменений.

    **Дополнительные замечания (опционально):**
    *   Любая важная информация: потенциальные риски, нерешенные вопросы, моменты, на которые стоит обратить особое внимание.

*   **Важно:** Избегай простого перечисления измененных файлов. Фокусируйся на *смысле* изменений.

# ФОРМАТ ВЫВОДА (строго соблюдать):

Title: <сгенерированный заголовок>

Description: <сгенерированное описание с использованием Markdown и предложенной структуры>
"""

    print(' отправка запроса к AI...')

    if args.use_gemini_free:
        response = send_gemini_free_request(api_key, prompt)
    else:
        model = os.getenv('OPENROUTER_MODEL', 'google/gemini-2.0-flash-001')
        response = send_openrouter_request(api_key, model, prompt)

    if not response:
        print('Ошибка получения ответа от AI.')
        return

    answer = ''
    if args.use_gemini_free and 'candidates' in response:
        candidate = response['candidates'][0]
        content = candidate.get('content') or {}
        parts = content.get('parts') or []
        answer = ''.join(str(p.get('text', '')) for p in parts).strip()
    elif 'choices' in response:
        answer = response['choices'][0]['message']['content'].strip()
    else:
        answer = response.get('output', '') or response.get('content', '')

    if not answer:
        print('Не удалось извлечь текст из ответа AI.')
        print('Полный ответ:', json.dumps(response, ensure_ascii=False, indent=2))
        return

    print(answer)
    set_clipboard_text(answer)
    notify('AI MR Helper', 'Ответ AI скопирован в буфер обмена.')


if __name__ == '__main__':
    main()
